Object.defineProperty(exports,"__esModule",{value:true});var _values2=require("lodash/values");var _values3=_interopRequireDefault(_values2);var _sortBy2=require("lodash/sortBy");var _sortBy3=_interopRequireDefault(_sortBy2);var _invert2=require("lodash/invert");var _invert3=_interopRequireDefault(_invert2);
var _axis=require("../../helpers/axis");var _axis2=_interopRequireDefault(_axis);
var _wrapper=require("../../helpers/wrapper");var _wrapper2=_interopRequireDefault(_wrapper);
var _react=require("react");var _react2=_interopRequireDefault(_react);
var _victoryCore=require("victory-core");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else{return Array.from(arr);}}

var identity=function identity(x){return x;};exports.default=

{
getChildComponents:function getChildComponents(props,defaultAxes){
var childComponents=_react2.default.Children.toArray(props.children);
if(childComponents.length===0){
return[defaultAxes.independent,defaultAxes.dependent];
}

var axisComponents={
dependent:_axis2.default.getAxisComponentsWithParent(childComponents,"dependent"),
independent:_axis2.default.getAxisComponentsWithParent(childComponents,"independent")};


if(axisComponents.dependent.length===0&&axisComponents.independent.length===0){
return childComponents.concat([defaultAxes.independent,defaultAxes.dependent]);
}
if(axisComponents.dependent.length>1||axisComponents.independent.length>1){
var msg="Only one VictoryAxis component of each axis type is allowed when "+"using the VictoryChart wrapper. Only the first axis will be used. Please compose "+"multi-axis charts manually";


_victoryCore.Log.warn(msg);
var dataComponents=this.getDataComponents(childComponents);
return _victoryCore.Collection.removeUndefined(
dataComponents.concat([axisComponents.dependent[0],axisComponents.independent[0]]));

}
return childComponents;
},

getDefaultDomainPadding:function getDefaultDomainPadding(childComponents,horizontal){
var groupComponent=childComponents.filter(function(child){
return child.type&&child.type.role&&child.type.role==="group-wrapper";
});

if(groupComponent.length<1){
return undefined;
}var _groupComponent$0$pro=

groupComponent[0].props,offset=_groupComponent$0$pro.offset,children=_groupComponent$0$pro.children;
return horizontal?
{y:offset*children.length/2}:
{x:offset*children.length/2};
},

getDataComponents:function getDataComponents(childComponents){
var findDataComponents=function findDataComponents(children){
return children.reduce(function(memo,child){
if(child.type&&child.type.role==="axis"){
return memo;
}else if(child.props&&child.props.children){
return memo.concat(findDataComponents(_react2.default.Children.toArray(child.props.children)));
}
return memo.concat(child);
},[]);
};

return findDataComponents(childComponents);
},

getDomain:function getDomain(props,axis,childComponents){
childComponents=childComponents||_react2.default.Children.toArray(props.children);
var domain=_wrapper2.default.getDomain(props,axis,childComponents);
var orientations=_axis2.default.getAxisOrientations(childComponents);
return _victoryCore.Domain.orientDomain(domain,orientations,axis);
},

getAxisOffset:function getAxisOffset(props,calculatedProps){var
axisComponents=calculatedProps.axisComponents,scale=calculatedProps.scale,origin=calculatedProps.origin,originSign=calculatedProps.originSign;

var axisOrientations={
x:_axis2.default.getOrientation(axisComponents.x,"x",originSign.x),
y:_axis2.default.getOrientation(axisComponents.y,"y",originSign.y)};

var orientationOffset={
x:axisOrientations.y==="left"?0:props.width,
y:axisOrientations.x==="bottom"?props.height:0};

var calculatedOffset={
x:Math.abs(orientationOffset.x-scale.x(origin.x)),
y:Math.abs(orientationOffset.y-scale.y(origin.y))};


return{
x:axisComponents.x&&axisComponents.x.offsetX!==undefined?
axisComponents.x.offsetX:calculatedOffset.x,
y:axisComponents.y&&axisComponents.y.offsetY!==undefined?
axisComponents.y.offsetY:calculatedOffset.y};

},

getTicksFromData:function getTicksFromData(calculatedProps,axis){
var currentAxis=_victoryCore.Helpers.getCurrentAxis(axis,calculatedProps.horizontal);
var stringMap=calculatedProps.stringMap[currentAxis];

var categoryArray=calculatedProps.categories[currentAxis];
var ticksFromCategories=categoryArray&&_victoryCore.Collection.containsOnlyStrings(categoryArray)?
categoryArray.map(function(tick){return stringMap[tick];}):categoryArray;
var ticksFromStringMap=stringMap&&(0,_values3.default)(stringMap);

return ticksFromCategories&&ticksFromCategories.length!==0?
ticksFromCategories:ticksFromStringMap;
},

getTicksFromAxis:function getTicksFromAxis(calculatedProps,axis,component){
var tickValues=component.props.tickValues;
if(!tickValues){
return undefined;
}
var currentAxis=_victoryCore.Helpers.getCurrentAxis(axis,calculatedProps.horizontal);
var stringMap=calculatedProps.stringMap[currentAxis];
return _victoryCore.Collection.containsOnlyStrings(tickValues)&&stringMap?
tickValues.map(function(tick){return stringMap[tick];}):tickValues;
},

getTicks:function getTicks(){
return this.getTicksFromAxis.apply(this,arguments)||this.getTicksFromData.apply(this,arguments);
},

getTickFormat:function getTickFormat(component,axis,calculatedProps){
var currentAxis=_victoryCore.Helpers.getCurrentAxis(axis,calculatedProps.horizontal);
var stringMap=calculatedProps.stringMap[currentAxis];
var tickValues=component.props.tickValues;
var useIdentity=tickValues&&!_victoryCore.Collection.containsStrings(tickValues)&&
!_victoryCore.Collection.containsDates(tickValues);
if(useIdentity){
return identity;
}else if(stringMap!==null){
var tickValueArray=(0,_sortBy3.default)((0,_values3.default)(stringMap),function(n){return n;});
var invertedStringMap=(0,_invert3.default)(stringMap);
var dataNames=tickValueArray.map(function(tick){return invertedStringMap[tick];});

var dataTicks=[""].concat(_toConsumableArray(dataNames),[""]);
return function(x){return dataTicks[x];};
}else{
return calculatedProps.scale[currentAxis].tickFormat()||identity;
}
},

createStringMap:function createStringMap(props,axis,childComponents){
var allStrings=_wrapper2.default.getStringsFromChildren(props,axis,childComponents);
return allStrings.length===0?null:
allStrings.reduce(function(memo,string,index){
memo[string]=index+1;
return memo;
},{});
}};